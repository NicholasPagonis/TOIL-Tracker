import { PrismaClient } from "@prisma/client";
import { fromZonedTime } from "date-fns-tz";
import { addDays, setHours, setMinutes, setSeconds, startOfDay } from "date-fns";

const prisma = new PrismaClient({
  datasources: {
    db: { url: process.env.DATABASE_URL ?? "file:./dev.db" },
  },
});

const PERTH_TZ = "Australia/Perth";

function perthTime(
  dateStr: string,
  hour: number,
  minute: number = 0
): Date {
  const localStr = `${dateStr}T${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}:00`;
  return fromZonedTime(localStr, PERTH_TZ);
}

function getLastMonday(): Date {
  const today = new Date();
  const day = today.getDay(); // 0 = Sun, 1 = Mon ...
  // Go back to the Monday 2 weeks ago
  const daysToLastMonday = ((day + 6) % 7) + 7;
  const monday = new Date(today);
  monday.setDate(today.getDate() - daysToLastMonday);
  return startOfDay(monday);
}

async function seed(): Promise<void> {
  console.log("ðŸŒ± Seeding database...");

  // Clear existing data
  await prisma.auditLog.deleteMany();
  await prisma.break.deleteMany();
  await prisma.session.deleteMany();
  await prisma.settings.deleteMany();

  // Create settings
  await prisma.settings.create({
    data: {
      id: "singleton",
      standardDailyMinutes: 456, // 7h 36m
      roundingRule: "NONE",
      allowNegativeTil: false,
      reportSubjectTemplate: "TOIL Report {from} to {to}",
      reportFooter: "Generated by TOIL Tracker",
      reportRecipientEmails: "[]",
    },
  });

  const monday = getLastMonday();

  // Seed 2 weeks of weekday sessions (Monâ€“Fri)
  const weekdayData: {
    dayOffset: number;
    startHour: number;
    startMinute: number;
    endHour: number;
    endMinute: number;
    hasBreak: boolean;
    breakStart?: [number, number];
    breakEnd?: [number, number];
    notes?: string;
  }[] = [
    // Week 1
    {
      dayOffset: 0,
      startHour: 8,
      startMinute: 2,
      endHour: 17,
      endMinute: 15,
      hasBreak: true,
      breakStart: [12, 30],
      breakEnd: [13, 0],
      notes: "Regular Monday",
    },
    {
      dayOffset: 1,
      startHour: 7,
      startMinute: 45,
      endHour: 17,
      endMinute: 30,
      hasBreak: true,
      breakStart: [12, 0],
      breakEnd: [12, 30],
      notes: "Early start Tuesday",
    },
    {
      dayOffset: 2,
      startHour: 8,
      startMinute: 0,
      endHour: 16,
      endMinute: 45,
      hasBreak: false,
      notes: "Short day Wednesday",
    },
    {
      dayOffset: 3,
      startHour: 8,
      startMinute: 30,
      endHour: 18,
      endMinute: 0,
      hasBreak: true,
      breakStart: [13, 0],
      breakEnd: [13, 30],
      notes: "Late finish Thursday",
    },
    {
      dayOffset: 4,
      startHour: 8,
      startMinute: 0,
      endHour: 17,
      endMinute: 0,
      hasBreak: false,
      notes: "Standard Friday",
    },
    // Week 2
    {
      dayOffset: 7,
      startHour: 8,
      startMinute: 15,
      endHour: 17,
      endMinute: 45,
      hasBreak: true,
      breakStart: [12, 45],
      breakEnd: [13, 15],
      notes: "Monday week 2",
    },
    {
      dayOffset: 8,
      startHour: 7,
      startMinute: 30,
      endHour: 17,
      endMinute: 0,
      hasBreak: true,
      breakStart: [12, 0],
      breakEnd: [12, 30],
      notes: "Early Tuesday",
    },
    {
      dayOffset: 9,
      startHour: 8,
      startMinute: 0,
      endHour: 18,
      endMinute: 30,
      hasBreak: true,
      breakStart: [13, 0],
      breakEnd: [14, 0],
      notes: "Long day Wednesday",
    },
    {
      dayOffset: 10,
      startHour: 8,
      startMinute: 45,
      endHour: 17,
      endMinute: 30,
      hasBreak: false,
      notes: "Thursday",
    },
    {
      dayOffset: 11,
      startHour: 8,
      startMinute: 0,
      endHour: 16,
      endMinute: 30,
      hasBreak: false,
      notes: "Early finish Friday",
    },
  ];

  for (const day of weekdayData) {
    const sessionDate = addDays(monday, day.dayOffset);
    const dateStr = sessionDate.toISOString().split("T")[0];

    const startedAt = perthTime(dateStr, day.startHour, day.startMinute);
    const endedAt = perthTime(dateStr, day.endHour, day.endMinute);

    const session = await prisma.session.create({
      data: {
        startedAt,
        endedAt,
        source: "MANUAL",
        notes: day.notes ?? null,
      },
    });

    if (day.hasBreak && day.breakStart && day.breakEnd) {
      await prisma.break.create({
        data: {
          sessionId: session.id,
          startedAt: perthTime(dateStr, day.breakStart[0], day.breakStart[1]),
          endedAt: perthTime(dateStr, day.breakEnd[0], day.breakEnd[1]),
        },
      });
    }

    console.log(`  âœ“ Created session for ${dateStr}`);
  }

  // Audit log for seed
  await prisma.auditLog.create({
    data: {
      eventType: "CLOCK_IN",
      payload: JSON.stringify({ note: "Seeded by seed.ts" }),
    },
  });

  const count = await prisma.session.count();
  console.log(`âœ… Seeded ${count} sessions`);
}

seed()
  .catch((err) => {
    console.error("Seed failed:", err);
    process.exit(1);
  })
  .finally(() => prisma.$disconnect());
